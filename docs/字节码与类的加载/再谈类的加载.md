# 再谈类的加载

## 概述

类加载器是JVM执行类加载机制的前提。

`ClassLoader`的作用：

`ClassLoader`是Java的核心组件，所有的Class都是由`ClassLoader`进行加载的，`ClassLoder`负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的`java.lang.Class`对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，`ClassLoader`在装载阶段，只能影响到类的加载，而无法通过`ClassLoader`去改变类的链接和初始化行为。至于它是否可以运行，则由Exection Engine决定。

![类的加载器](https://github.com/jackhusky/jvm/blob/main/docs/images/类的加载器.jpg)

### 类加载器的分类

Class文件的显示加载和隐式加载的方式是指JVM加载class文件到内存的方式。

- 显示加载指的是在代码中通过调用`ClassLoader`加载class对象，如直接使用`Class.forName(name)`或`this.getClass().getClassLoader().loadClass()`加载class对象。
- 隐式加载则是不直接在代码中调用`ClassLoader`的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。

### 类加载器的必要性

一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。

- 避免遇到`java.lang.ClassNotFoundException`异常`java.lang.NoClassDefFoundError`异常时，手足无措。
- 需要支持类的动态加载或需要对编译后的字节码文件进行加密操作时，就需要与类加载器打交道了。
- 编写自定义了加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。

### 命名空间

1. 何为类的唯一性？

   对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即时这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。

2. 命名空间

- 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。
- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

在大型应用中，往往借助这一特性，来运行同一个类的不同版本。

### 类加载器的基本特征

- 双亲委派模型。但不是所有类加载器都遵循这个模型，有时候，启动类加载器锁加载的类型，是可能加载器用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。
- 可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，就没有办法利用类加载器去实现容器的逻辑。
- 单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“领居”（两个实例）间，同一类型仍然可以被加载多次，因为互相并不可见。

## 类的加载器分类

JVM支持两种类型的类加载器，分别为引导类加载器和自定义类加载器。

![类加载器分类](https://github.com/jackhusky/jvm/blob/main/docs/images/类加载器分类.png)

- 除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。
- 不同类加载器看似是继承关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。

### 引导类加载器

- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
- 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或`sun.boot.class.path`路径下的内容）。用于提供JVM自身需要的类。
- 并不继承自`java.lang.ClassLoader`，没有父加载器。
- 出于安全考虑，`Bootstrap`启动类加载器值加载包名为java、javax、sun等开头的类。
- 加载扩展类和应用类加载器，并指定为它们的父类加载器。

### 扩展类加载器

- Java语言编写，由sun,`misc.Launcher$ExtClassLoader`实现。
- 继承与`ClassLoader`类。
- 父类加载器为启动类加载器。
- 从`java.ext.dirs`系统属性所指定的目录下加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

### 系统类加载器

- Java语言编写，由`sun.misc.Launcher$AppClassLoader`实现。
- 继承于`ClassLoader`类。
- 父类加载器为扩展类加载器。
- 它负责加载环境变量`classpath`或系统属性`java.class.path`指定路径下的类库。
- 应用程序中的类加载器默认是系统类加载器。
- 它是用户自定义类加载器的默认父加载器。
- 通过`ClassLoader`的`getSystemClassLoader()`方法可以获取到该类加载器。

### 用户自定义类加载器

- 在Java的日常应用程序开发中，类的加载几乎是由上述3中类加载器相互配合执行的。在必要时，还可以自定义类加载器，来定制类的加载方式。
- 体现Java语言强大生命力和巨大魅力的关键因素之一是，Java开发者可以自定义类加载器来实现类库的动态加载，加载器可以是本地的JAR包，也可以是网络上的远程资源。
- 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现。
- 同时，自定义加载器能实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想。
- 自定义类加载器通常需要继承于`ClassLoader`。

## 测试不同的类加载器

每个`Class`对象都会包含一个定义它的`ClassLoader`的一个引用。

获取`ClassLoader`的途径

```java
	// 获得当前类的ClassLoader
	clazz.getClassLoader()
    // 获得当前线程上下文的ClassLoader
    Thread.currentThread().getContextClassLoader()
    // 获得系统的ClassLoader
    ClassLoader.getSystemClassLoader()
```

数组类的`Class`对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过`Class.getClassLoader()`返回的，与数组当中元素类型的类加载器是一样的。如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。

## ClassLoader源码分析

![ClassLoader与现有类加载器的关系](https://github.com/jackhusky/jvm/blob/main/docs/images/ClassLoader与现有类加载器的关系.png)

### ClassLoader的主要方法

- 

  ```java
  public final ClassLoader getParent()
  ```

  返回该类加载器的超类加载器

- ```java
  public Class<?> loadClass(String name) throws ClassNotFoundException
  ```

  加载名称为name的类，返回结果为`java.lang.Class`类的实例。如果找不到类，则返回`ClassNotFoundException`异常。该方法中的逻辑就是双亲委派模式的实现。

- ```java
  protected Class<?> findClass(String name) throws ClassNotFoundException 
  ```

  查找二进制名称为name的类，返回结果是`java.lang.Class`类的实例。这是一个受保护的方法，JVM鼓励重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查父类加载器之后被`loadClass()`方法调用。

  一般情况下，在自定义类加载器时，会直接覆盖`ClassLoader`的`findClass()`方法并编写加载规则，取得要加载类的字节码转换成流，然后调用`defineClass()`方法生成类的`Class`对象。

- ```java
  protected final Class<?> defineClass(String name, byte[] b, int off, int len)
  ```

  根据给定的字节数组b转换为`Class`的实例，off和len参数表示实际`Class`信息在`byte`数组中的位置和长度，其中`byte`数组b是`ClassLoader`从外部获取的。这是受保护的方法，只有在自定义`ClassLoader`子类中可以使用。 

- ```java
  protected final void resolveClass(Class<?> c)
  ```

  链接指定的一个Java类。使用该方法可以使用类的`Class`对象创建完成的同时也被解析。链接阶段主要是对字节码进行验证，为类变量分配内存并社会初始值同时将字节码文件中的符号引用转换为直接引用。

- ```java
  protected final Class<?> findLoadedClass(String name)
  ```

  查找名称为name的已经被加载的类，返回结果为`java.lang.Class`类的实例。这个方法是`final`方法，无法被修改。

- ```java
  private final ClassLoader parent
  ```

  它也是`ClassLoader`的实例，这个字段表示的`ClassLoader`也称为这个`ClassLoader`的双亲。在类加载的过程中，`ClassLoader`可能会将某些请求交予自己的双亲处理。

### SecureClassLoader与URLClassLoader

`SecureClassLoader`扩展了`ClassLoader`，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般不会直接跟这个类打交道，更多的是与它的子类`URLClassLoader`有所关联。

`ClassLoader`是一个抽象类，很多方法是空的没有实现，比如`findClass()`、`findResource()`等。而`URLClassLoader`这个实现类为这些方法提供了具体的实现，并新增了`URLClassPath`类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承`URLClassLoader`类，这样就可以避免自己去编写`findClass()`方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。

### ExtClassLoader与AppClassLoader

这两个类继承于`URLClassLoader`，是`sun.misc.Launcher`的静态内部类。`sun.misc.Launcher`主要被系统用于启动主应用程序，`ExtClassLoader`和`AppClassLoader`都是由`sun.misc.Laucher`创建的。

### Class.forName()与ClassLoader.loadClass()

`Class.forName()`：是一个静态方法，最常用的是`Class.forName(String className)`；根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。

`ClassLoader.loadClass()`：这是一个实例方法，需要一个`ClassLoader`对象来调用该方法。该方法将`Class`文件加载到内存时并不会执行类的初始化，知道这个类第一次使用时才进行初始化。

## 双亲委派模型

### 定义与本质

从JDK1.2版本开始，类的加载过程采用双亲委派机制。

1. 定义

如果一个类加载器在接到家在类的请求时，它首先不会自己尝试加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。

2. 本质

规定了类加载的顺序是：引导类加载器先加载，若加载不到，有扩展类加载器加载，若加载不到，才会由系统类加载器或自定义的类加载器进行加载。

### 优势与劣势

1. 双亲委派机制的优势

   - 避免类的重复加载，确保一个类的全局唯一性
   - 保护程序安全，防止核心API被随意篡改

2. 代码支持

   双亲委派机制在`java.lang.ClassLoader.loadClass(String, boolean)`接口中体现。逻辑如下：

   - 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。
   - 判断当前加载器的父加载器是否为空，如果不为空，则调用`parent.loadClass(name ,false)`接口进行加载
   - 反之，如果当前加载器的父类加载器为空，则调用`findBootstrapClassOrNull(name)`接口，让引导类加载器进行加载。
   - 如果通过上面3条路径都没能成功加载，则调用`findClass(name)`接口进行加载。该接口最终会调用`java.lang.ClassLoader`接口的`defineClass`系列的`native`接口加载目标Java类。

3. 双亲委派模式的弊端

   检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个`ClassLoader`的职责非常明确，但是同时会带来一个问题，即顶层的`ClassLoader`无法访问底层的`ClassLoader`所加载的类。

   通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定了一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。

4. 结论

   由于Java虚拟机规范并没有明确类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的的加载机制和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是`Servlet`规范推荐的一种做法。

### 破坏双亲委派机制

#### 破坏双亲委派机制1

双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者的类的加载器实现方式。

双亲委派模型的第一次”被破坏“其实发生在双亲委派模型出现之前——即JDK1.2面世以前的”远古“时代。由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类`java.lang.ClassLoader`则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入了双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免`loadClass()`被子类覆盖的可能性，只能在JDK1.2之后的`java.lang.ClassLoader`中添加一个新的`protected`方法`findClass()`，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在`loadClass()`中编写代码。按照`loadClass()`方法的逻辑，如果父类加载失败，会自动调用自己的`findClass()`方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。

#### 破坏双亲委派机制2

双亲委派模型的第二次”被破坏“是由模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为”基础”，是因为他们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，该怎么办呢？

这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Servcie Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那么怎么办？（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）

为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文加载器（Thread Context ClassLoader）。这个类加载器可以通过`java.lang.Thread`类的`setContentClassLoader()`方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用类加载器。

有了线程上下文加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的额层次结构来逆向使用类加载器。已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中设计SPI的加载基本都是采用这种方式来完成，例如：JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种不优雅的实现方式，在JDK6时，JDK提供了`java.util.ServiceLoader`类，以META-INF/service中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。

![破坏双亲委派机制2](https://github.com/jackhusky/jvm/blob/main/docs/images/破坏双亲委派机制2.png)

默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。

双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。

IBM公司主导的JSR-291（即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中的Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。

当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:

1. 将以java.*开头的类，委派给父类加载器加载。

2. 否则，将委派列表名单内的类，委派给父类加载器。

3. 否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器。

4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。

5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundel的类加载器加载。

6. 否则，查找Dynamic Import列表的Bundle，委托给对应Bundle的类加载器加载。

7. 否则，类查找失败。

   说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。

### 热替换的实现

热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分基本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。

但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用`ClassLoader`。

注意：由不同`ClassLoader`加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的`ClassLoader`加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。

根据这个特点，可以用来模拟热替换的实现，基本思路如图：

![热替换](https://github.com/jackhusky/jvm/blob/main/docs/images/热替换.jpg)

## 沙箱安全机制

- 保护程序安全
- 保护Java原生的JDK代码

Java安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境。

沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的优先隔离，防止对本地系统造成破坏。

沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

所有的Java程序运行都可以指定沙箱，可以定制安全策略。

![沙箱安全机制](https://github.com/jackhusky/jvm/blob/main/docs/images/沙箱安全机制.jpg)

JDK1.0时期：在Java中将执行程序分成本地代码和远程代码两种，本地代码默认是可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码，可以访问一切本地资源。对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱机制。

JDK1.1时期：JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。

JDK1.2时期：再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。

JDK1.6时期：当前最新的安全机制实现，则引入了域（Domain）的概念。虚拟机会把代码加载到不同 的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域的类文件就具有了当前域的全部权限，

## 自定义类加载器

1. 为什么要自定义类加载器

   - 隔离加载类

   在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个web应用服务器上的不同应用程序。（类的仲裁——>类冲突）

   - 修改类加载的方式

   类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载。

   - 扩展加载源

   比如从数据库、网络、甚至是电视机顶盒进行加载。

   - 防止源码泄漏

   Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。

2. 常见的场景
   - 实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如：两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。
   - 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统，或者是需要自己操纵字节码，动态修改或者生成类型。

### 实现方式

1. 实现方式

- Java提供了抽象类`java.lang.ClassLoader`，所有用户自定义的类加载器都应该继承`ClassLoader`类。
- 在自定义`ClassLoader`的子类时候，我们常见的会有两种做法：
  - 方式一：重写`loadClass()`方法
  - 方式二：重写`findClass()`方法  ——>推荐

2. 对比

   这两种方法本质上差不多，毕竟`loadClass()`也会调用`findClass()`，但是从逻辑上讲我们最好不要直接修改`loadClass()`的内部逻辑。建议的做法是只在`findClass()`重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。

- `loadClass()`这个方法是实现双亲委派模型的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写`loadClass()`方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。
- 当编写好自定义类加载器后，便可以在程序中调用`loadClass()`方法来实现类加载操作。

3. 说明

- 父类加载器是系统类加载器
- JVM中的所有类加载都会使用`java.lang.ClassLoader.loadClass(String)`接口（自定义类加载器并重写`java.lang.ClassLoader.loadClass(String)`接口的除外），连JDK的核心类库也不能例外。 

```java
public class MyClassLoader extends ClassLoader {
    private String byteCodePath;

    public MyClassLoader(String byteCodePath) {
        this.byteCodePath = byteCodePath;
    }

    public MyClassLoader(ClassLoader parent, String byteCodePath) {
        super(parent);
        this.byteCodePath = byteCodePath;
    }

    @Override
    protected Class<?> findClass(String className) throws ClassNotFoundException {
        BufferedInputStream bis = null;
        ByteArrayOutputStream baos = null;
        try {
            //获取字节码文件的完整路径
            String fileName = byteCodePath + className + ".class";
            //获取一个输入流
            bis = new BufferedInputStream(new FileInputStream(fileName));
            //获取一个输出流
            baos = new ByteArrayOutputStream();
            //具体读入数据并写出的过程
            int len;
            byte[] data = new byte[1024];
            while ((len = bis.read(data)) != -1) {
                baos.write(data, 0, len);
            }
            //获取内存中的完整的字节数组的数据
            byte[] byteCodes = baos.toByteArray();
            //调用defineClass()，将字节数组的数据转换为Class的实例。
            Class clazz = defineClass(null, byteCodes, 0, byteCodes.length);
            return clazz;
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (baos != null)
                    baos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (bis != null)
                    bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }
}
```

```java
public class MyClassLoaderTest {
    public static void main(String[] args) {
        MyClassLoader loader = new MyClassLoader("d:/");

        try {
            Class clazz = loader.loadClass("Demo1");
            System.out.println("加载此类的类的加载器为：" + clazz.getClassLoader().getClass().getName());

            System.out.println("加载当前Demo1类的类的加载器的父类加载器为：" + clazz.getClassLoader().getParent().getClass().getName());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```



## Java9新特性

为了保证兼容性，JDK 9没有从根本上改变三层了类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得注意的变动。

1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform classloader）。可以通过`ClassLoader`的新方法`getPlatformClassLoader()`来获取。

   JDK9基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然的满足了可扩展的需求，那自然无需在保留JAVA_HOME\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。

2. 平台类加载器和应用类加载器都不再继承自`java.net.URLClassLoader`。现在启动类加载器、平台类加载器、应用程序类加载器全部继承于`jdk.internal.loader.BuiltinClassLoader`。

![JDK9类加载器](https://github.com/jackhusky/jvm/blob/main/docs/images/JDK9类加载器.png)

3. 在Java9中，类加载器有了名称，该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。
4. 启动类加载器现在是在JVM内部和Java类库共同协作实现的类加载器（以前是C++实现），但为了与之前diamante兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到`BootClassLoader`实例。
5. 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。

![JDK9及以前双亲委派模型](https://github.com/jackhusky/jvm/blob/main/docs/images/JDK9及以前双亲委派模型.png)