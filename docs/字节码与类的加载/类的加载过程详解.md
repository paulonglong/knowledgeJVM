# 类的加载过程详解

## 概述

在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型是由虚拟机预先定义，引用数据类型则需要进行类的加载。

按照Java虚拟机规范，从class文件到加载到内存中的类，到卸载出内存为止，它的整个生命周期包括7个阶段：

![类的生命周期](https://github.com/jackhusky/jvm/blob/main/docs/images/类的生命周期.png)

## 过程一：Loading（加载）阶段

### 加载完成的操作

#### 加载的理解

所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型—类模板对象。所谓类模板对象，就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期间便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。

反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。

#### 加载完成的操作

加载阶段，就是查找并加载类的二进制数据，生成Class的实例。

在加载类时，Java虚拟机必须完成以下3件事情：

- 通过类的全名，获取类的二进制数据流。
- 解析类的二进制数据流为方法区的数据结构（Java类模型）。
- 创建`java.lang.Class`类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。

### 二进制流的获取方式

- 虚拟机可能通过文件系统读入一个class后缀的文件（最常见）
- 读入jar、zip等归档数据包，提取类文件
- 事先存放在数据库的类的二进制数据
- 使用类似于HTTP之类的协议通过网络进行加载
- 在运行时生成一段Class的二进制信息等

在读取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个`java.lang.Class`的实例。

### 类模型与Class实例的位置

#### 类模型的位置

加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDK1.8之前：永久代；JDK1.8及之后：元空间）。

#### Class实例的位置

类将.class文件加载至元空间后，会在堆中创建一个`java.lang.Class`对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。

![类模型位置及class实例位置](https://github.com/jackhusky/jvm/blob/main/docs/images/类模型位置及class实例位置.png)

外部可以通过访问代表Order类的Class对象来获取Order的类数据结构。

Class类的构造方法是私有的，只有JVM才能创建。

### 数组类的加载

创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类的过程：

1. 如果数组的元素类型是引用类型，那么久遵循定义的加载过程递归加载和创建数组A的元素类型。
2. JVM使用指定的元素类型和数组维度来创建新的数组类。

如果数组的元素类型引用类型，数组类的可访问性就由元素类型的可访问性决定，否则数组类的可访问性将被缺省定义为`public`

## 过程二：Linking（链接）阶段

### 环节1：链接阶段之Verification（验证）

当类加载到系统后，就开始链接操作，验证是链接操作的第一步。

它的目的是保证加载字节码是合法、合理并符合规范的。

![链接阶段之验证](https://github.com/jackhusky/jvm/blob/main/docs/images/链接阶段之验证.png)

- 其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。
- 格式验证之外的验证操作将会在方法区中进行。

链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。

#### 具体说明

1. 格式验证：是否以魔数`0xCAFEBABE`开头，主版本和副版本是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度。

2. Java虚拟机会进行字节码的语义检查但凡在语义上不符合规范的，虚拟机也不会给予验证通过。

   - 是否所有的类都有父类的存在（在Java里，除了`Object`其他类都应该有父类）
   - 是否一些被定义为`final`的方法或者类被重写或继承了
   - 非抽象类是否实现了所有抽象方法或者接口方法
   - 是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；`abstract`情况下的方法，就不能是`final`的了）

3. Java虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码的分析，判断字节码是否可以被正确地执行。

   - 在字节码的执行过程中，是否会跳转到一条不存在的指令
   - 函数的调用是否传递了正确类型的参数
   - 变量的赋值是否给了正确的数据类型等

   栈映射桢（`StackMapTable`）就是在这个阶段，用于检测在特定的字节码出，其局部变量表和操作数栈是否有正确的数据类型。但遗憾的是，该过程只是尽可能地检查出可以预知的明显的问题。如果这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。

在前面3此检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能保证类时没有问题的。

4. 检验器还将进行符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出`NoClassDefFoundError`，如果一个方法无法找到，则会抛出`NoSuchMethodError`。此阶段在解析环节才会执行。

### 环节2：链接阶段之Preparation（准备）

准备阶段简而言之，为类的静态变量分配内存，并将其初始化为默认值。

当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表。

| 类型      | 默认初始值 |
| --------- | ---------- |
| byte      | (byte)0    |
| short     | (short)0   |
| int       | 0          |
| long      | 0L         |
| float     | 0.0f       |
| double    | 0.0        |
| char      | \u0000     |
| boolean   | false      |
| reference | null       |

注意：

1. 这里不包含基本数据类型的字段用`static final`修饰的情况，因为`final`在编译的时候就会分配了，准备阶段会显示赋值。
2. 注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
3. 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。

### 环节3：链接阶段之Resolution（解析）

 解析阶段，简而言之就是将类、接口、字段、方法的符号引用转为直接引用。

符号引用就是一些字面量的引用，和虚拟机的内部数据结构、内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如`println()`方法被调用时，需要明确知道方法的位置。

以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表的位置，从而使得方法被成功引用。

Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSport VM中，加载、验证、准备、初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会帮随着JVM在执行完初始化之后再执行。

## 过程三：initialization（初始化）阶段

初始化阶段，简而言之，为类的静态变量赋予正确的初始值。

1. 具体描述

   类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类开始执行Java字节码。（即：到了初始化阶段，才真正开始执行类定义的Java程序代码）

   初始化阶段的重要工作是执行类的初始化方法：`<clinit>()`方法。

   - 该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是有字节码指令所组成。
   - 它是由类静态成员的赋值语句以及`static`语句块合并产生的。

2. 说明

   在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的`<clinit>()`总是在子类`<clinit>()`之前被调用。也就是说，父类的`static`块优先级高于子类。

   Java编译器并不会为所有的类都产生`<clinit>()`初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含`<clinit>()`方法？

   - 一个类中没有声明任何的类变量，也没有静态代码块时。
   - 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。
   - 一个类中包含`static final`修饰的基本数据类型的字段，这些类字段初始化语句采用编译时变量表达式。

### static与final的搭配问题

对于基本数据类型的字段来说，如果使用`static final`修饰，则显示赋值（直接赋值，而非调用方法）通常是在链接阶段的准备环节进行。

对于`String`来说， 如果使用字面量的方式赋值，使用`static final`修饰的话，则显示赋值通常是在链接阶段的准备环节进行。

最终结论：使用`static final`修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或`String`类型的显示赋值，是在链接阶段的准备环节进行。除此之外，在初始化`<clinit>()`方法中进行。

### `<clinit>()`的线程安全性

对于`<clinit>()`方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。

虚拟机会保证一个了的`<clinit>()`方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，知道活动线程执行`<clinit>()`方法完毕。

正式因为函数`<clinit>()`带锁线程安全的，因此，如果一个类的`<clinit>()`方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。

如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行`<clinit>()`方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。

### 类的初始化情况：主动使用vs被动使用

Java程序对类的使用分为两种：主动使用和被动使用。-`XX:+TraceClassLoading`，可以追踪类的加载信息并打印出来。

#### 主动使用

Class只有在必须要首次使用的时候次啊会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）

1. 当创建一个类的实例时，比如使用`new`关键字，或者通过反射、克隆、反序列化。
2. 当调用类的静态方法时，即当使用了字节码`invokestatic`指令。
3. 当使用类、接口的静态字段时（`final`修饰特殊考虑），比如，使用`getstatic`或者`putstatic`指令。（对应访问变量、赋值变量操作）
4. 当使用`java.lang.reflect`包中的方法反射类的方法时。比如：`Class.forName(“com.xxx.Test”)`
5. 当初始化子类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
6. 如果一个接口定义了`default`方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。
7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。
8. 当初次调用`MethodHandle`实例时，初始化该`MethodHandle`指向的方法所在的类。（涉及解析`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`方法句柄对应的类）

针对5，补充说明

当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。

- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。

#### 被动使用

除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。

也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。

1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。
   - 当通过子类引用父类的静态变量，不会导致子类初始化
2. 通过数组定义类引用，不会触发此类的初始化。
3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显示赋值了。
4. 调用`ClassLoader`类的`loadClass()`方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

## 过程四：类的Using（使用）

## 过程五：类的Unloading（卸载）

#### 类、类的加载器、类的实例之间的引用关系

在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的`getClassLoader()`方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。

一个类的实例总是引用代表这个类的`Class`对象。在`Object`类中定义了`getClass()`方法，这个方法返回代表对象所属类的`Class`对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的`Class`对象。

#### 类的生命周期

当`Sample`类被加载、链接和初始化后，它的生命周期就开始了。当代表`Sample`类的`Class`对象不再被引用，即不可触及时，`Class`对象就会结束生命周期，`Sample`类在方法区内的数据也会被卸载，从而结束`Sample`类的生命周期。

一个类何时结束生命周期，取决于代表它的`Class`对象何时结束生命周期。

#### 具体例子

![类的卸载](https://github.com/jackhusky/jvm/blob/main/docs/images/类的卸载.png)

#### 类的卸载

1. 启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）
2. 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。
3. 被开发者自定义的类加载器实例加载的类型只有在其和简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很对用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。

